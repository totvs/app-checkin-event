#include 'tlpp-core.th'

namespace		tlpp.rest
using namespace	tlpp.rest


/*/{tlpp.doc} class handleHttp
Classe de controle para comunicação com o HTTP REST da camada do appserver

@author  denardi
@since   05/2019
/*/
class handleHttp

	public  data nThreadID
	private data cCallFrom
	private data cPrintIni
	private data oHttpReq
    private data oHttpResp
    private data oVdrCtx
	private data nthPId
	private data hObjects

	public  method new( thPId )
	public  method destroy()
	public  method handle()
	private method console( cMessage )
	private method httpCall()
	private method httpCallClass()
	private method httpCallFunc()
    public  method httpError( oError, nThreadID )

endclass


/*/{tlpp.doc} Method new
Constructor

@author  denardi
@since   05/2019
/*/
method new( thPId ) class handleHttp
	::nthPId	:= thPId
	::nThreadID	:= ThreadID()
	::cCallFrom	:= ProcName(1)
	::cPrintIni	:= '[TLPP] [REST] [Thread ' + cValtoChar( ::nThreadID ) + '] [thPId ' + cValtoChar( ::nthPId ) + '] '
	::hObjects	:= JsonObject():New()

	sleep(300)
	::console( 'thread started' )
return .T.


/*/{tlpp.doc} Method destroy
Destructor

@author  denardi
@since   05/2019
/*/
method destroy() class handleHttp

	local oClass
    local nA        := 0
    local aObjects  := {}

    ::nThreadID   := Nil
	::cCallFrom   := Nil
	::cPrintIni   := Nil
	::nthPId      := Nil

    aObjects  := ::hObjects:GetProperties()
    for nA = 1 to len( aObjects )
        oClass := ::hObjects[ aObjects[nA] ]
        FreeObj( oClass )
    next nA

    FreeObj( ::hObjects  )
    FreeObj( ::oHttpReq  )
    FreeObj( ::oHttpResp )
    FreeObj( ::oVdrCtx   )
return .T.


/*/{tlpp.doc} Method console
Executa conout com padrão para o tlpp.rest

@author  denardi
@since   05/2019
/*/
method console( cMessage ) class handleHttp
	conout( ::cPrintIni + cMessage + CRLF )
return .T.


/*/{tlpp.doc} Method handle
Método principal para controle das conexões

@author  denardi
@since   05/2019
/*/
method handle() class handleHttp

    // Inicialização componentes HTTP
        ::oHttpReq	:= VdrHttpReq():New()
        ::oHttpResp	:= VdrHttpResp():New()
        ::oVdrCtx	:= VdrCtx():New( ::nthPId, ::oHttpReq, ::oHttpResp )

	::console( 'waiting request....' )
		while ( ::oVdrCtx:WaitRequest() .and. !killapp() )
			if ( ::httpCall() )
				::oVdrCtx:Receive()
			else
				exit
			endif
		enddo
	::console( 'stoped waiting request' )
/*
    if ( ::oVdrCtx:Status == ::oVdrCtx:NoError )
		::console( 'finishing JOB through manager control' )
    else
		::console( 'current JOB completed and starting a new JOB' )
        StartJob( ::cCallFrom, getenvserver(), .F., ::nthPId )
    endif
*/
return .T.


/*/{tlpp.doc} Method httpCall
Verifica se a implementação do Rest foi feito em Classe ou Função e executa o método correspondente

@author  denardi
@since   05/2019
/*/
method httpCall() class handleHttp
    if ( ::oVdrCtx:ClassName != Nil )
		return ::httpCallClass()
    endif
return ::httpCallFunc()


/*/{tlpp.doc} Method httpCallClass
Executa a implementação do Rest foi feito em Classe

@author  denardi
@since   05/2019
/*/
method httpCallClass() class handleHttp

    local lRet		    := .T.
    local bErrorBlock   := ErrorBlock( {|e| ::httpError(e,::nThreadID)} )
	local oClass

    Begin Sequence
        if ( ::hObjects:HasProperty(::oVdrCtx:ClassName) )
            oClass := ::hObjects[::oVdrCtx:ClassName]
        else
            oClass := eval(&("{||" + ::oVdrCtx:ClassName + "():New()}"))
            ::hObjects[::oVdrCtx:ClassName] := oClass
        endif

        if ( eval(&("{|req, resp|oClass:" + ::oVdrCtx:FunctionName + "(req, resp)}"), ::oVdrCtx:HttpReq, ::oVdrCtx:HttpResp) == .F. )
            ::oVdrCtx:Close()
        endif
    Recover 
        lRet := .F.
    End Sequence

    ErrorBlock( bErrorBlock )
return lRet


/*/{tlpp.doc} Method httpCallFunc
Executa a implementação do Rest foi feito em Função

@author  denardi
@since   05/2019
/*/
method httpCallFunc() class handleHttp

	local lRet	        := .T.
    local bErrorBlock   := ErrorBlock({|e| ::httpError(e,::nThreadID)})

    Begin Sequence
        if ( eval(&("{|req, resp|" + ::oVdrCtx:FunctionName + "(req, resp)}"), ::oVdrCtx:HttpReq, ::oVdrCtx:HttpResp) == .F. )
            ::oVdrCtx:Close()
        endif
    Recover
        lRet := .F.
    End Sequence

    ErrorBlock( bErrorBlock )
return lRet


/*/{tlpp.doc} Method httpError
Tratamento de erro

@author  denardi
@since   05/2019
/*/
method httpError( oError, nThreadID ) class handleHttp

    local cFullMessage  := ''
    local cSmallMessage := ''

    if ( nThreadID == ::nThreadID )

        if ( ::oVdrCtx <> Nil .and. ::oVdrCtx:HttpReq <> Nil )
            cSmallMessage := "execution error, endpoint: " + ::oVdrCtx:HttpReq:Url

            cFullMessage  := "execution error... "
            cFullMessage  += chr(10) + chr(10) + "endpoint: " + chr(10) +  ::oVdrCtx:HttpReq:Url
        endif

        if ( oError <> Nil )
            cSmallMessage += " | description: " + cValTochar(oError:Description) + " | "

            cFullMessage  += chr(10) + chr(10) + "description: " + chr(10) + cValTochar(oError:Description)
            cFullMessage  += chr(10) + chr(10) + "error stack: " + cValTochar(oError:ErrorStack)
            cFullMessage  += chr(10) + "environment: " + chr(10) + cValTochar(oError:ErrorEnv)
        endif

        if ( ::oVdrCtx <> Nil )
            if ::oVdrCtx:HttpReq <> Nil .and. ::oVdrCtx:HttpResp <> Nil
                ::oVdrCtx:HttpResp:Status = 500
                ::oVdrCtx:HttpResp:send( cFullMessage )
            else
                ::oVdrCtx:send( cFullMessage )
            endif
        endif

        ::console( cSmallMessage )

        BREAK
    endif

return
